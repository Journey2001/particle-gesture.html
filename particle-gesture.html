<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­æ§åˆ¶ - æ‰‹åŠ¿è¯†åˆ«</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #canvas-container { width: 100vw; height: 100vh; }
        
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #control-panel h3 {
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 16px;
            color: #8af;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8af;
            cursor: pointer;
        }
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2a;
            color: #fff;
            font-size: 14px;
        }
        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }
        .value-display {
            float: right;
            color: #8af;
            font-size: 12px;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #8af;
            color: #000;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .btn:hover { background: #9bf; }
        .btn.active { background: #f88; }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            z-index: 200;
        }
        #status {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-size: 14px;
            color: #8f8;
        }
        #gesture-status {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-size: 14px;
            color: #fa8;
        }
        #webcam-video {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid rgba(136, 170, 255, 0.5);
            object-fit: cover;
            z-index: 100;
            display: none;
            transform: scaleX(-1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="loading">è¯·é€‰æ‹©ä¸€å¼ å›¾ç‰‡å¼€å§‹</div>
    <div id="canvas-container"></div>
    <video id="webcam-video" autoplay playsinline></video>
    
    <div id="control-panel">
        <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
        
        <div class="control-group">
            <label>é€‰æ‹©å›¾ç‰‡</label>
            <input type="file" id="image-upload" accept="image/*" style="width:100%; color:#aaa; font-size:12px;">
        </div>
        
        <button class="btn" id="toggle-btn">èšåˆæˆå›¾æ¡ˆ</button>
        
        <div id="status">å½“å‰çŠ¶æ€ï¼šæ‰©æ•£æ—‹è½¬</div>
        
        <button class="btn" id="gesture-btn">å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</button>
        <div id="gesture-status">æ‰‹åŠ¿ï¼šæœªå¯ç”¨</div>
        <p style="font-size:11px; color:#888; margin-top:8px;">âœŠ æ¡æ‹³ â†’ èšåˆå›¾æ¡ˆ | ğŸ–ï¸ å¼ å¼€ â†’ æ‰©æ•£æ—‹è½¬</p>
        
        <div class="control-group">
            <label>ç²’å­æ•°é‡ <span class="value-display" id="particle-count-val">10000</span></label>
            <input type="number" id="particle-count" value="10000" min="500" max="20000" step="500">
        </div>
        
        <div class="control-group">
            <label>å›¾æ¡ˆå¤§å° <span class="value-display" id="pattern-scale-val">50%</span></label>
            <input type="range" id="pattern-scale" value="50" min="10" max="100">
        </div>
        
        <div class="control-group">
            <label>æ—‹è½¬é€Ÿåº¦ <span class="value-display" id="rotation-speed-val">1.0</span></label>
            <input type="range" id="rotation-speed" value="10" min="1" max="30">
        </div>
        
        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="particle-color" value="#88aaff">
        </div>
        
        <button class="btn" id="fullscreen-btn">å…¨å±åˆ‡æ¢</button>
    </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        // ========== è°ƒè¯•æ—¥å¿—ç³»ç»Ÿ ==========
        const debugLog = (tag, message, data = null) => {
            const timestamp = new Date().toISOString().substr(11, 12);
            const logMsg = `[${timestamp}][${tag}] ${message}`;
            console.log(logMsg, data !== null ? data : '');
            
            // åŒæ—¶æ˜¾ç¤ºåœ¨é¡µé¢ä¸Šæ–¹ä¾¿ç§»åŠ¨ç«¯æŸ¥çœ‹
            let debugPanel = document.getElementById('debug-panel');
            if (!debugPanel) {
                debugPanel = document.createElement('div');
                debugPanel.id = 'debug-panel';
                debugPanel.style.cssText = 'position:fixed;top:0;left:0;right:0;max-height:200px;overflow-y:auto;background:rgba(0,0,0,0.9);color:#0f0;font-size:11px;padding:5px;z-index:9999;font-family:monospace;';
                document.body.appendChild(debugPanel);
            }
            const line = document.createElement('div');
            line.textContent = logMsg + (data !== null ? ' ' + JSON.stringify(data) : '');
            debugPanel.appendChild(line);
            debugPanel.scrollTop = debugPanel.scrollHeight;
        };

        debugLog('INIT', 'è„šæœ¬å¼€å§‹æ‰§è¡Œ');
        debugLog('INIT', 'UserAgent', navigator.userAgent);
        debugLog('INIT', 'å¹³å°', navigator.platform);
        debugLog('INIT', 'æ˜¯å¦æ”¯æŒWebGL', !!window.WebGLRenderingContext);

        // ========== MediaPipe æ¨¡å—å¯¼å…¥ ==========
        debugLog('IMPORT', 'å¼€å§‹å¯¼å…¥ MediaPipe æ¨¡å—...');
        let HandLandmarker, FilesetResolver;
        try {
            const module = await import("https://unpkg.com/@mediapipe/tasks-vision@0.10.0");
            HandLandmarker = module.HandLandmarker;
            FilesetResolver = module.FilesetResolver;
            debugLog('IMPORT', 'MediaPipe æ¨¡å—å¯¼å…¥æˆåŠŸ', { 
                hasHandLandmarker: !!HandLandmarker, 
                hasFilesetResolver: !!FilesetResolver 
            });
        } catch (importError) {
            debugLog('IMPORT', 'MediaPipe æ¨¡å—å¯¼å…¥å¤±è´¥', { 
                error: importError.message, 
                stack: importError.stack 
            });
        }

        // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½æˆåŠŸ
        debugLog('INIT', 'æ£€æŸ¥ Three.js', { 
            hasThree: typeof THREE !== 'undefined',
            threeVersion: typeof THREE !== 'undefined' ? THREE.REVISION : 'N/A'
        });
        
        if (typeof THREE === 'undefined') {
            debugLog('INIT', 'Three.js æœªåŠ è½½ï¼è¯·æ£€æŸ¥ç½‘ç»œ');
            throw new Error('Three.js æœªåŠ è½½');
        }
        
        let currentImageData = null;
        let scene, camera, renderer, particles;
        let particlePositions, targetPositions, originalPositions;
        let isCollapsed = false;  // false=æ‰©æ•£, true=èšåˆ
        let rotationAngle = 0;
        
        let config = {
            particleCount: 10000,
            patternScale: 0.5,
            rotationSpeed: 1.0,
            particleColor: new THREE.Color(0x88aaff)
        };

        // æ‰‹åŠ¿è¯†åˆ«ç›¸å…³
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        let currentGesture = '';
        let gestureEnabled = false;

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        let imageAspect = 1;
        
        function sampleFromImage(img, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            imageAspect = img.width / img.height;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            const validPixels = [];
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    if (pixels[i + 3] > 128) {
                        validPixels.push({ x, y });
                    }
                }
            }
            
            const sampled = [];
            for (let i = 0; i < count; i++) {
                if (validPixels.length === 0) break;
                const idx = Math.floor(Math.random() * validPixels.length);
                const p = validPixels[idx];
                sampled.push({
                    x: (p.x / canvas.width - 0.5) * 2 * imageAspect,
                    y: -(p.y / canvas.height - 0.5) * 2
                });
            }
            
            while (sampled.length < count && validPixels.length > 0) {
                const idx = Math.floor(Math.random() * validPixels.length);
                const p = validPixels[idx];
                sampled.push({
                    x: (p.x / canvas.width - 0.5) * 2 * imageAspect,
                    y: -(p.y / canvas.height - 0.5) * 2
                });
            }
            
            return sampled;
        }

        async function createParticles() {
            debugLog('PARTICLE', 'å¼€å§‹åˆ›å»ºç²’å­');
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }
            
            if (!currentImageData) {
                debugLog('PARTICLE', 'æ²¡æœ‰å›¾ç‰‡æ•°æ®');
                document.getElementById('loading').textContent = 'è¯·å…ˆé€‰æ‹©ä¸€å¼ å›¾ç‰‡';
                document.getElementById('loading').style.display = 'block';
                return;
            }
            
            debugLog('PARTICLE', 'åŠ è½½å›¾ç‰‡ä¸­...');
            const img = await loadImage(currentImageData);
            debugLog('PARTICLE', 'å›¾ç‰‡åŠ è½½å®Œæˆ', { width: img.width, height: img.height });
            const sampledPoints = sampleFromImage(img, config.particleCount);
            const count = sampledPoints.length;
            
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(count * 3);
            targetPositions = new Float32Array(count * 3);
            originalPositions = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 10;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * 10;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 5;
                
                const scale = config.patternScale * 4;
                originalPositions[i3] = sampledPoints[i].x * scale;
                originalPositions[i3 + 1] = sampledPoints[i].y * scale;
                originalPositions[i3 + 2] = 0;
                
                targetPositions[i3] = particlePositions[i3];
                targetPositions[i3 + 1] = particlePositions[i3 + 1];
                targetPositions[i3 + 2] = particlePositions[i3 + 2];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const material = new THREE.PointsMaterial({
                color: config.particleColor,
                size: 0.03,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            document.getElementById('loading').style.display = 'none';
        }
        
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!particles) {
                renderer.render(scene, camera);
                return;
            }
            
            const positions = particles.geometry.attributes.position.array;
            const count = positions.length / 3;
            
            if (!isCollapsed) {
                rotationAngle += 0.01 * config.rotationSpeed;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const seed = i * 0.618;
                    const r = Math.pow((seed * 7.13) % 1, 1/3) * 3;
                    
                    const phi = Math.acos(1 - 2 * (i + 0.5) / count);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i + rotationAngle;
                    
                    const baseX = r * Math.sin(phi) * Math.cos(theta);
                    const baseY = r * Math.sin(phi) * Math.sin(theta);
                    const baseZ = r * Math.cos(phi);
                    
                    const phase = i * 0.37;
                    const jitterX = Math.sin(time * 2.1 + phase) * 0.15;
                    const jitterY = Math.cos(time * 1.7 + phase * 1.3) * 0.15;
                    const jitterZ = Math.sin(time * 2.5 + phase * 0.8) * 0.15;
                    
                    targetPositions[i3] = baseX + jitterX;
                    targetPositions[i3 + 1] = baseY + jitterY;
                    targetPositions[i3 + 2] = baseZ + jitterZ;
                }
            } else {
                const time = Date.now() * 0.001;
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const phase = i * 0.1;
                    const floatX = Math.sin(time * 1.5 + phase) * 0.02;
                    const floatY = Math.cos(time * 1.2 + phase * 0.7) * 0.02;
                    const floatZ = Math.sin(time * 0.8 + phase * 1.3) * 0.03;
                    const breathe = 1 + Math.sin(time * 0.5) * 0.03;
                    
                    targetPositions[i3] = originalPositions[i3] * breathe + floatX;
                    targetPositions[i3 + 1] = originalPositions[i3 + 1] * breathe + floatY;
                    targetPositions[i3 + 2] = originalPositions[i3 + 2] + floatZ;
                }
            }
            
            const lerpFactor = 0.05;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] += (targetPositions[i3] - positions[i3]) * lerpFactor;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * lerpFactor;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * lerpFactor;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        async function createHandLandmarker() {
            debugLog('HAND', 'å¼€å§‹åˆ›å»º HandLandmarker...');
            
            // æ£€æŸ¥æ¨¡å—æ˜¯å¦å·²åŠ è½½
            if (!FilesetResolver || !HandLandmarker) {
                debugLog('HAND', 'MediaPipe æ¨¡å—æœªåŠ è½½', { 
                    FilesetResolver: !!FilesetResolver, 
                    HandLandmarker: !!HandLandmarker 
                });
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ¨¡å—æœªåŠ è½½';
                return false;
            }

            try {
                // Step 1: åŠ è½½ FilesetResolver
                debugLog('HAND', 'Step 1: å¼€å§‹åŠ è½½ FilesetResolver (WASM)...');
                const wasmUrl = "https://unpkg.com/@mediapipe/tasks-vision@0.10.0/wasm";
                debugLog('HAND', 'WASM URL', wasmUrl);
                
                const filesetResolver = await FilesetResolver.forVisionTasks(wasmUrl);
                debugLog('HAND', 'Step 1 å®Œæˆ: FilesetResolver åŠ è½½æˆåŠŸ', { 
                    type: typeof filesetResolver 
                });

                // Step 2: åˆ›å»º HandLandmarker
                debugLog('HAND', 'Step 2: å¼€å§‹åˆ›å»º HandLandmarker...');
                // ä½¿ç”¨æœ¬åœ°æ¨¡å‹æ–‡ä»¶
                const modelUrl = "./hand_landmarker.task";
                debugLog('HAND', 'æ¨¡å‹ URL', modelUrl);
                
                // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡ï¼Œç§»åŠ¨è®¾å¤‡ä½¿ç”¨ CPU é¿å…å…¼å®¹æ€§é—®é¢˜
                const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
                const options = {
                    baseOptions: {
                        modelAssetPath: modelUrl,
                        delegate: isMobile ? "CPU" : "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                };
                debugLog('HAND', 'è®¾å¤‡ç±»å‹', { isMobile, delegate: options.baseOptions.delegate });
                debugLog('HAND', 'åˆ›å»ºé€‰é¡¹', options);

                handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, options);
                debugLog('HAND', 'Step 2 å®Œæˆ: HandLandmarker åˆ›å»ºæˆåŠŸ', { 
                    type: typeof handLandmarker 
                });
                
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ¨¡å‹å·²åŠ è½½';
                return true;
            } catch (error) {
                debugLog('HAND', 'HandLandmarker åˆ›å»ºå¤±è´¥', { 
                    name: error.name,
                    message: error.message, 
                    stack: error.stack 
                });
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šåŠ è½½å¤±è´¥ - ' + error.message;
                return false;
            }
        }

        function startWebcam() {
            debugLog('WEBCAM', 'å¼€å§‹å¯åŠ¨æ‘„åƒå¤´...');
            const video = document.getElementById('webcam-video');
            
            // æ£€æŸ¥ mediaDevices API æ˜¯å¦å¯ç”¨
            if (!navigator.mediaDevices) {
                debugLog('WEBCAM', 'navigator.mediaDevices ä¸å¯ç”¨');
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šä¸æ”¯æŒæ‘„åƒå¤´API';
                document.getElementById('gesture-status').style.color = '#f88';
                return;
            }
            
            if (!navigator.mediaDevices.getUserMedia) {
                debugLog('WEBCAM', 'getUserMedia ä¸å¯ç”¨');
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šä¸æ”¯æŒgetUserMedia';
                document.getElementById('gesture-status').style.color = '#f88';
                return;
            }

            debugLog('WEBCAM', 'è¯·æ±‚æ‘„åƒå¤´æƒé™...');
            
            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šä½¿ç”¨å‰ç½®æ‘„åƒå¤´
            const constraints = { 
                video: { 
                    facingMode: 'user',  // å‰ç½®æ‘„åƒå¤´
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            };
            debugLog('WEBCAM', 'æ‘„åƒå¤´çº¦æŸ', constraints);

            navigator.mediaDevices.getUserMedia(constraints)
                .then((stream) => {
                    debugLog('WEBCAM', 'æ‘„åƒå¤´æƒé™è·å–æˆåŠŸ', {
                        tracks: stream.getTracks().map(t => ({ kind: t.kind, label: t.label, readyState: t.readyState }))
                    });
                    video.srcObject = stream;
                    video.style.display = 'block';
                    
                    video.addEventListener('loadeddata', () => {
                        debugLog('WEBCAM', 'è§†é¢‘æ•°æ®å·²åŠ è½½', {
                            videoWidth: video.videoWidth,
                            videoHeight: video.videoHeight,
                            readyState: video.readyState
                        });
                        predictWebcam();
                    });
                    
                    video.addEventListener('error', (e) => {
                        debugLog('WEBCAM', 'è§†é¢‘å…ƒç´ é”™è¯¯', { error: e.message });
                    });
                    
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šå·²å¯ç”¨';
                    document.getElementById('gesture-status').style.color = '#8f8';
                })
                .catch((err) => {
                    debugLog('WEBCAM', 'æ‘„åƒå¤´è®¿é—®å¤±è´¥', { 
                        name: err.name, 
                        message: err.message,
                        constraint: err.constraint 
                    });
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ‘„åƒå¤´é”™è¯¯ - ' + err.message;
                    document.getElementById('gesture-status').style.color = '#f88';
                    gestureEnabled = false;
                    document.getElementById('gesture-btn').textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                    document.getElementById('gesture-btn').classList.remove('active');
                });
        }

        function stopWebcam() {
            const video = document.getElementById('webcam-video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            video.style.display = 'none';
            document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæœªå¯ç”¨';
            document.getElementById('gesture-status').style.color = '#fa8';
        }

        let predictCallCount = 0;
        let lastPredictLog = 0;
        
        function predictWebcam() {
            const video = document.getElementById('webcam-video');
            predictCallCount++;
            
            // æ¯5ç§’è¾“å‡ºä¸€æ¬¡çŠ¶æ€æ—¥å¿—
            const now = Date.now();
            if (now - lastPredictLog > 5000) {
                debugLog('PREDICT', 'æ£€æµ‹å¾ªç¯çŠ¶æ€', {
                    callCount: predictCallCount,
                    hasHandLandmarker: !!handLandmarker,
                    hasVideoSrc: !!video.srcObject,
                    gestureEnabled: gestureEnabled,
                    videoTime: video.currentTime,
                    videoReady: video.readyState
                });
                lastPredictLog = now;
            }
            
            if (!handLandmarker || !video.srcObject || !gestureEnabled) {
                if (gestureEnabled) requestAnimationFrame(predictWebcam);
                return;
            }

            const nowInMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                try {
                    const results = handLandmarker.detectForVideo(video, nowInMs);
                    
                    // æ¯50å¸§è¾“å‡ºä¸€æ¬¡æ£€æµ‹ç»“æœï¼ˆçº¦æ¯ç§’1-2æ¬¡ï¼‰
                    if (predictCallCount % 50 === 0) {
                        debugLog('DETECT', 'æ£€æµ‹ç»“æœ', {
                            hasLandmarks: !!(results.landmarks && results.landmarks.length > 0),
                            landmarksCount: results.landmarks ? results.landmarks.length : 0,
                            handedness: results.handedness ? results.handedness.length : 0
                        });
                    }
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        const newGesture = determineGesture(results.landmarks[0]);
                        
                        // æ¯æ¬¡æ£€æµ‹åˆ°æ‰‹éƒ½è¾“å‡ºæ—¥å¿—
                        if (predictCallCount % 30 === 0) {
                            debugLog('DETECT', 'æ£€æµ‹åˆ°æ‰‹', { 
                                gesture: newGesture,
                                currentGesture: currentGesture,
                                landmarksSample: results.landmarks[0].slice(0, 5).map(p => ({x: p.x.toFixed(2), y: p.y.toFixed(2)}))
                            });
                        }
                        
                        if (newGesture && newGesture !== currentGesture) {
                            currentGesture = newGesture;
                            debugLog('GESTURE', 'æ‰‹åŠ¿å˜åŒ–', { gesture: currentGesture });
                            
                            if (currentGesture === 'Fist' && !isCollapsed) {
                                // æ¡æ‹³ â†’ èšåˆæˆå›¾æ¡ˆ
                                setCollapsed(true);
                            } else if (currentGesture === 'Open' && isCollapsed) {
                                // å¼ å¼€ â†’ æ‰©æ•£æ—‹è½¬
                                setCollapsed(false);
                            }
                            
                            document.getElementById('gesture-status').textContent = 
                                `æ‰‹åŠ¿ï¼š${currentGesture === 'Fist' ? 'âœŠ æ¡æ‹³' : currentGesture === 'Open' ? 'ğŸ–ï¸ å¼ å¼€' : 'è¯†åˆ«ä¸­...'}`;
                        }
                    }
                } catch (detectError) {
                    debugLog('PREDICT', 'æ£€æµ‹å‡ºé”™', { 
                        name: detectError.name,
                        message: detectError.message 
                    });
                }
            }

            if (gestureEnabled) requestAnimationFrame(predictWebcam);
        }

        // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ï¼šæŒ‡å°–yåæ ‡ < æŒ‡æ ¹å…³èŠ‚yåæ ‡
        function fingerExtended(landmarks, tip, pip) {
            return landmarks[tip].y < landmarks[pip].y;
        }

        // æ‹‡æŒ‡ç‰¹æ®Šå¤„ç†ï¼šç”¨xæ–¹å‘åˆ¤æ–­ï¼ˆè€ƒè™‘å·¦å³æ‰‹ï¼‰
        function thumbExtended(landmarks) {
            const wrist = landmarks[0];
            const indexMcp = landmarks[5];
            const isRightHand = wrist.x < indexMcp.x;
            const tip = landmarks[4];
            const ip = landmarks[3];
            return isRightHand ? (tip.x < ip.x) : (tip.x > ip.x);
        }

        function determineGesture(landmarks) {
            // ç»Ÿè®¡ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡
            const ext = [
                thumbExtended(landmarks),           // æ‹‡æŒ‡
                fingerExtended(landmarks, 8, 6),    // é£ŸæŒ‡ï¼šæŒ‡å°–vsæŒ‡æ ¹
                fingerExtended(landmarks, 12, 10),  // ä¸­æŒ‡
                fingerExtended(landmarks, 16, 14),  // æ— åæŒ‡
                fingerExtended(landmarks, 20, 18),  // å°æŒ‡
            ];
            const count = ext.filter(Boolean).length;

            // 0-1æ ¹æ‰‹æŒ‡ä¼¸å‡º = æ¡æ‹³
            if (count <= 1) {
                return 'Fist';
            }
            
            // 4-5æ ¹æ‰‹æŒ‡ä¼¸å‡º = å¼ å¼€
            if (count >= 4) {
                return 'Open';
            }

            return null;
        }

        function setCollapsed(collapsed) {
            isCollapsed = collapsed;
            const toggleBtn = document.getElementById('toggle-btn');
            const status = document.getElementById('status');
            
            if (isCollapsed) {
                toggleBtn.textContent = 'æ‰©æ•£æ—‹è½¬';
                toggleBtn.classList.add('active');
                status.textContent = 'å½“å‰çŠ¶æ€ï¼šèšåˆæˆå›¾æ¡ˆ';
                status.style.color = '#f88';
            } else {
                toggleBtn.textContent = 'èšåˆæˆå›¾æ¡ˆ';
                toggleBtn.classList.remove('active');
                status.textContent = 'å½“å‰çŠ¶æ€ï¼šæ‰©æ•£æ—‹è½¬';
                status.style.color = '#8f8';
            }
        }

        function initUI() {
            const toggleBtn = document.getElementById('toggle-btn');
            const gestureBtn = document.getElementById('gesture-btn');
            
            toggleBtn.addEventListener('click', () => {
                setCollapsed(!isCollapsed);
            });
            
            gestureBtn.addEventListener('click', async () => {
                debugLog('UI', 'æ‰‹åŠ¿æŒ‰é’®ç‚¹å‡»', { currentEnabled: gestureEnabled });
                
                if (!gestureEnabled) {
                    gestureBtn.textContent = 'åŠ è½½ä¸­...';
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ­£åœ¨åŠ è½½æ¨¡å‹...';
                    
                    if (!handLandmarker) {
                        debugLog('UI', 'å¼€å§‹åŠ è½½ HandLandmarker...');
                        const success = await createHandLandmarker();
                        debugLog('UI', 'HandLandmarker åŠ è½½ç»“æœ', { success });
                        if (!success) {
                            gestureBtn.textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                            return;
                        }
                    }
                    gestureEnabled = true;
                    gestureBtn.textContent = 'å…³é—­æ‰‹åŠ¿æ§åˆ¶';
                    gestureBtn.classList.add('active');
                    debugLog('UI', 'å¼€å§‹å¯åŠ¨æ‘„åƒå¤´');
                    startWebcam();
                } else {
                    debugLog('UI', 'å…³é—­æ‰‹åŠ¿æ§åˆ¶');
                    gestureEnabled = false;
                    gestureBtn.textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                    gestureBtn.classList.remove('active');
                    stopWebcam();
                }
            });
            
            document.getElementById('particle-count').addEventListener('change', (e) => {
                config.particleCount = parseInt(e.target.value);
                document.getElementById('particle-count-val').textContent = config.particleCount;
                createParticles();
            });
            
            document.getElementById('pattern-scale').addEventListener('input', (e) => {
                config.patternScale = e.target.value / 100;
                document.getElementById('pattern-scale-val').textContent = e.target.value + '%';
                updatePatternScale();
            });
            
            document.getElementById('rotation-speed').addEventListener('input', (e) => {
                config.rotationSpeed = e.target.value / 10;
                document.getElementById('rotation-speed-val').textContent = config.rotationSpeed.toFixed(1);
            });
            
            document.getElementById('particle-color').addEventListener('input', (e) => {
                config.particleColor = new THREE.Color(e.target.value);
                if (particles) particles.material.color = config.particleColor;
            });
            
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                    hideUI();
                } else {
                    document.exitFullscreen();
                }
            });
            
            // ESC é”®åˆ‡æ¢ UI æ˜¾ç¤º
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    toggleUI();
                }
            });
            
            document.getElementById('image-upload').addEventListener('change', (e) => {
                debugLog('UI', 'å›¾ç‰‡é€‰æ‹©äº‹ä»¶è§¦å‘');
                const file = e.target.files[0];
                if (file) {
                    debugLog('UI', 'é€‰æ‹©äº†æ–‡ä»¶', { name: file.name, size: file.size, type: file.type });
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        debugLog('UI', 'æ–‡ä»¶è¯»å–å®Œæˆ');
                        currentImageData = event.target.result;
                        createParticles();
                    };
                    reader.onerror = (err) => {
                        debugLog('UI', 'æ–‡ä»¶è¯»å–å¤±è´¥', { error: err });
                    };
                    reader.readAsDataURL(file);
                } else {
                    debugLog('UI', 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
                }
            });
        }
        
        function updatePatternScale() {
            if (!originalPositions || !currentImageData) return;
            const count = originalPositions.length / 3;
            const scale = config.patternScale * 4;
            
            loadImage(currentImageData).then(img => {
                const sampledPoints = sampleFromImage(img, count);
                for (let i = 0; i < Math.min(count, sampledPoints.length); i++) {
                    const i3 = i * 3;
                    originalPositions[i3] = sampledPoints[i].x * scale;
                    originalPositions[i3 + 1] = sampledPoints[i].y * scale;
                }
            });
        }

        let uiHidden = false;
        
        function hideUI() {
            uiHidden = true;
            document.getElementById('control-panel').style.display = 'none';
            document.getElementById('webcam-video').style.visibility = 'hidden';
        }
        
        function showUI() {
            uiHidden = false;
            document.getElementById('control-panel').style.display = 'block';
            if (gestureEnabled) {
                document.getElementById('webcam-video').style.visibility = 'visible';
            }
        }
        
        function toggleUI() {
            if (uiHidden) {
                showUI();
            } else {
                hideUI();
            }
        }

        try {
            debugLog('INIT', 'å¼€å§‹åˆå§‹åŒ– Three.js');
            initThree();
            debugLog('INIT', 'Three.js åˆå§‹åŒ–å®Œæˆ');
            
            debugLog('INIT', 'å¼€å§‹åˆå§‹åŒ– UI');
            initUI();
            debugLog('INIT', 'UI åˆå§‹åŒ–å®Œæˆ');
            
            debugLog('INIT', 'å¼€å§‹åŠ¨ç”»å¾ªç¯');
            animate();
            debugLog('INIT', 'å…¨éƒ¨åˆå§‹åŒ–å®Œæˆ');
        } catch (initError) {
            debugLog('INIT', 'åˆå§‹åŒ–å¤±è´¥', { 
                name: initError.name, 
                message: initError.message,
                stack: initError.stack 
            });
        }
    </script>
</body>
</html>
