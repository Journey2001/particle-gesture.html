<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­æ§åˆ¶ - æ‰‹åŠ¿è¯†åˆ«</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #canvas-container { width: 100vw; height: 100vh; }
        
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #control-panel h3 {
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 16px;
            color: #8af;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #aaa;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #8af;
            cursor: pointer;
        }
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2a;
            color: #fff;
            font-size: 14px;
        }
        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }
        .value-display {
            float: right;
            color: #8af;
            font-size: 12px;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #8af;
            color: #000;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .btn:hover { background: #9bf; }
        .btn.active { background: #f88; }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            z-index: 200;
        }
        #status {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-size: 14px;
            color: #8f8;
        }
        #gesture-status {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            font-size: 14px;
            color: #fa8;
        }
        #webcam-video {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid rgba(136, 170, 255, 0.5);
            object-fit: cover;
            z-index: 100;
            display: none;
            transform: scaleX(-1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="loading">è¯·é€‰æ‹©ä¸€å¼ å›¾ç‰‡å¼€å§‹</div>
    <div id="canvas-container"></div>
    <video id="webcam-video" autoplay playsinline></video>
    
    <div id="control-panel">
        <h3>ğŸ® æ§åˆ¶é¢æ¿ <span id="fps-display" style="float:right;color:#8f8;font-size:12px;">-- FPS</span> <span id="mem-display" style="float:right;color:#aaa;font-size:10px;margin-right:10px;">--MB</span></h3>
        
        <div class="control-group">
            <label>é€‰æ‹©å›¾ç‰‡</label>
            <input type="file" id="image-upload" accept="image/*" style="width:100%; color:#aaa; font-size:12px;">
        </div>
        
        <button class="btn" id="toggle-btn">èšåˆæˆå›¾æ¡ˆ</button>
        
        <div id="status">å½“å‰çŠ¶æ€ï¼šæ‰©æ•£æ—‹è½¬</div>
        
        <button class="btn" id="gesture-btn">å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</button>
        <div id="gesture-status">æ‰‹åŠ¿ï¼šæœªå¯ç”¨</div>
        <p style="font-size:11px; color:#888; margin-top:8px;">âœŠ æ¡æ‹³ â†’ èšåˆå›¾æ¡ˆ | ğŸ–ï¸ å¼ å¼€ â†’ æ‰©æ•£æ—‹è½¬</p>
        
        <div class="control-group">
            <label>æ‰‹åŠ¿æ£€æµ‹é¢‘ç‡ <span class="value-display" id="detect-interval-val">50ms</span></label>
            <input type="range" id="detect-interval" value="50" min="30" max="200" step="10">
        </div>
        
        <div class="control-group">
            <label>ç²’å­æ•°é‡ <span class="value-display" id="particle-count-val">10000</span></label>
            <input type="number" id="particle-count" value="10000" min="500" max="20000" step="500">
        </div>
        
        <div class="control-group">
            <label>å›¾æ¡ˆå¤§å° <span class="value-display" id="pattern-scale-val">50%</span></label>
            <input type="range" id="pattern-scale" value="50" min="10" max="100">
        </div>
        
        <div class="control-group">
            <label>æ—‹è½¬é€Ÿåº¦ <span class="value-display" id="rotation-speed-val">1.0</span></label>
            <input type="range" id="rotation-speed" value="10" min="1" max="30">
        </div>
        
        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="particle-color" value="#88aaff">
        </div>
        
        <div class="control-group">
            <label>æ¸²æŸ“è´¨é‡ <span class="value-display" id="pixel-ratio-val">2.0</span></label>
            <input type="range" id="pixel-ratio" value="20" min="5" max="20" step="5">
        </div>
        
        <button class="btn" id="fullscreen-btn">å…¨å±åˆ‡æ¢</button>
    </div>

    <!-- Three.js: ä¼˜å…ˆç”¨ unpkgï¼Œå’Œ MediaPipe åŒä¸€ä¸ª CDNï¼Œä»£ç†æ—¶éƒ½èƒ½è®¿é—® -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script type="module">
        // ========== è°ƒè¯•æ—¥å¿—ç³»ç»Ÿ ==========
        let debugVisible = false; // é»˜è®¤éšè—
        
        // åˆ›å»ºè°ƒè¯•é¢æ¿å’Œåˆ‡æ¢æŒ‰é’®
        const debugPanel = document.createElement('div');
        debugPanel.id = 'debug-panel';
        debugPanel.style.cssText = 'position:fixed;top:30px;left:0;right:0;max-height:200px;overflow-y:auto;background:rgba(0,0,0,0.9);color:#0f0;font-size:11px;padding:5px;z-index:9998;font-family:monospace;display:none;';
        document.body.appendChild(debugPanel);
        
        const debugToggleBtn = document.createElement('button');
        debugToggleBtn.textContent = 'ğŸ“‹ Log';
        debugToggleBtn.style.cssText = 'position:fixed;top:5px;left:5px;z-index:9999;padding:3px 8px;font-size:11px;background:#333;color:#0f0;border:1px solid #0f0;border-radius:4px;cursor:pointer;';
        debugToggleBtn.onclick = () => {
            debugVisible = !debugVisible;
            debugPanel.style.display = debugVisible ? 'block' : 'none';
        };
        document.body.appendChild(debugToggleBtn);
        
        const MAX_LOG_LINES = 100; // é™åˆ¶æœ€å¤§æ—¥å¿—è¡Œæ•°
        const debugLog = (tag, message, data = null) => {
            const timestamp = new Date().toISOString().substr(11, 12);
            const logMsg = `[${timestamp}][${tag}] ${message}`;
            console.log(logMsg, data !== null ? data : '');
            
            const line = document.createElement('div');
            line.textContent = logMsg + (data !== null ? ' ' + JSON.stringify(data) : '');
            debugPanel.appendChild(line);
            
            // é™åˆ¶æ—¥å¿—æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
            while (debugPanel.childNodes.length > MAX_LOG_LINES) {
                debugPanel.removeChild(debugPanel.firstChild);
            }
            debugPanel.scrollTop = debugPanel.scrollHeight;
        };

        debugLog('INIT', 'è„šæœ¬å¼€å§‹æ‰§è¡Œ');
        debugLog('INIT', 'UserAgent', navigator.userAgent);
        debugLog('INIT', 'å¹³å°', navigator.platform);
        debugLog('INIT', 'æ˜¯å¦æ”¯æŒWebGL', !!window.WebGLRenderingContext);

        // ========== MediaPipe æ¨¡å—å¯¼å…¥ ==========
        debugLog('IMPORT', 'å¼€å§‹å¯¼å…¥ MediaPipe æ¨¡å—...');
        let HandLandmarker, FilesetResolver;
        try {
            const module = await import("https://unpkg.com/@mediapipe/tasks-vision@0.10.0");
            HandLandmarker = module.HandLandmarker;
            FilesetResolver = module.FilesetResolver;
            debugLog('IMPORT', 'MediaPipe æ¨¡å—å¯¼å…¥æˆåŠŸ', { 
                hasHandLandmarker: !!HandLandmarker, 
                hasFilesetResolver: !!FilesetResolver 
            });
        } catch (importError) {
            debugLog('IMPORT', 'MediaPipe æ¨¡å—å¯¼å…¥å¤±è´¥', { 
                error: importError.message, 
                stack: importError.stack 
            });
        }

        // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½æˆåŠŸ
        debugLog('INIT', 'æ£€æŸ¥ Three.js', { 
            hasThree: typeof THREE !== 'undefined',
            threeVersion: typeof THREE !== 'undefined' ? THREE.REVISION : 'N/A'
        });
        
        if (typeof THREE === 'undefined') {
            debugLog('INIT', 'Three.js æœªåŠ è½½ï¼è¯·æ£€æŸ¥ç½‘ç»œ');
            throw new Error('Three.js æœªåŠ è½½');
        }
        
        let currentImageData = null;
        let scene, camera, renderer, particles;
        let particlePositions, targetPositions, originalPositions;
        let isCollapsed = false;  // false=æ‰©æ•£, true=èšåˆ
        let rotationAngle = 0;
        
        // ========== æœ¬åœ°å­˜å‚¨åŠŸèƒ½ ==========
        function loadConfig() {
            try {
                const saved = localStorage.getItem('particle-gesture-config');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    debugLog('CONFIG', 'è¯»å–æœ¬åœ°é…ç½®', parsed);
                    return {
                        particleCount: parsed.particleCount || 10000,
                        patternScale: parsed.patternScale || 0.5,
                        rotationSpeed: parsed.rotationSpeed || 1.0,
                        particleColor: new THREE.Color(parsed.particleColorHex || 0x88aaff),
                        particleColorHex: parsed.particleColorHex || '#88aaff',
                        pixelRatio: parsed.pixelRatio || 2.0,
                        detectInterval: parsed.detectInterval || 50
                    };
                }
            } catch (e) {
                debugLog('CONFIG', 'è¯»å–é…ç½®å¤±è´¥', e.message);
            }
            return null;
        }
        
        function saveConfig() {
            try {
                const toSave = {
                    particleCount: config.particleCount,
                    patternScale: config.patternScale,
                    rotationSpeed: config.rotationSpeed,
                    particleColorHex: config.particleColorHex,
                    pixelRatio: config.pixelRatio,
                    detectInterval: config.detectInterval
                };
                localStorage.setItem('particle-gesture-config', JSON.stringify(toSave));
                debugLog('CONFIG', 'ä¿å­˜é…ç½®', toSave);
            } catch (e) {
                debugLog('CONFIG', 'ä¿å­˜é…ç½®å¤±è´¥', e.message);
            }
        }
        
        // åŠ è½½ä¿å­˜çš„é…ç½®æˆ–ä½¿ç”¨é»˜è®¤å€¼
        const savedConfig = loadConfig();
        let config = savedConfig || {
            particleCount: 10000,
            patternScale: 0.5,
            rotationSpeed: 1.0,
            particleColor: new THREE.Color(0x88aaff),
            particleColorHex: '#88aaff',
            pixelRatio: 2.0,
            detectInterval: 50
        };
        if (!config.particleColorHex) config.particleColorHex = '#88aaff';
        if (!config.pixelRatio) config.pixelRatio = Math.min(window.devicePixelRatio, 2);
        if (!config.detectInterval) config.detectInterval = 50;

        // æ‰‹åŠ¿è¯†åˆ«ç›¸å…³
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        let currentGesture = '';
        let gestureEnabled = false;

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(config.pixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        let imageAspect = 1;
        
        function sampleFromImage(img, count) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            imageAspect = img.width / img.height;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            const validPixels = [];
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    if (pixels[i + 3] > 128) {
                        validPixels.push({ x, y });
                    }
                }
            }
            
            const sampled = [];
            for (let i = 0; i < count; i++) {
                if (validPixels.length === 0) break;
                const idx = Math.floor(Math.random() * validPixels.length);
                const p = validPixels[idx];
                sampled.push({
                    x: (p.x / canvas.width - 0.5) * 2 * imageAspect,
                    y: -(p.y / canvas.height - 0.5) * 2
                });
            }
            
            while (sampled.length < count && validPixels.length > 0) {
                const idx = Math.floor(Math.random() * validPixels.length);
                const p = validPixels[idx];
                sampled.push({
                    x: (p.x / canvas.width - 0.5) * 2 * imageAspect,
                    y: -(p.y / canvas.height - 0.5) * 2
                });
            }
            
            return sampled;
        }

        async function createParticles() {
            debugLog('PARTICLE', 'å¼€å§‹åˆ›å»ºç²’å­');
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }
            
            if (!currentImageData) {
                debugLog('PARTICLE', 'æ²¡æœ‰å›¾ç‰‡æ•°æ®');
                document.getElementById('loading').textContent = 'è¯·å…ˆé€‰æ‹©ä¸€å¼ å›¾ç‰‡';
                document.getElementById('loading').style.display = 'block';
                return;
            }
            
            debugLog('PARTICLE', 'åŠ è½½å›¾ç‰‡ä¸­...');
            const img = await loadImage(currentImageData);
            debugLog('PARTICLE', 'å›¾ç‰‡åŠ è½½å®Œæˆ', { width: img.width, height: img.height });
            const sampledPoints = sampleFromImage(img, config.particleCount);
            const count = sampledPoints.length;
            
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(count * 3);
            targetPositions = new Float32Array(count * 3);
            originalPositions = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 10;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * 10;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 5;
                
                const scale = config.patternScale * 4;
                originalPositions[i3] = sampledPoints[i].x * scale;
                originalPositions[i3 + 1] = sampledPoints[i].y * scale;
                originalPositions[i3 + 2] = 0;
                
                targetPositions[i3] = particlePositions[i3];
                targetPositions[i3 + 1] = particlePositions[i3 + 1];
                targetPositions[i3 + 2] = particlePositions[i3 + 2];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const material = new THREE.PointsMaterial({
                color: config.particleColor,
                size: 0.03,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            document.getElementById('loading').style.display = 'none';
        }
        
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        // FPS è®¡ç®—
        let frameCount = 0;
        let lastFpsTime = performance.now();
        
        // ä¸‰è§’å‡½æ•°æŸ¥è¡¨ä¼˜åŒ–
        const TABLE_SIZE = 4096;
        const TABLE_MASK = TABLE_SIZE - 1;
        const sinTable = new Float32Array(TABLE_SIZE);
        const cosTable = new Float32Array(TABLE_SIZE);
        for (let i = 0; i < TABLE_SIZE; i++) {
            const angle = (i / TABLE_SIZE) * Math.PI * 2;
            sinTable[i] = Math.sin(angle);
            cosTable[i] = Math.cos(angle);
        }
        // å¿«é€ŸæŸ¥è¡¨å‡½æ•°ï¼Œè¾“å…¥å¼§åº¦
        const fastSin = (rad) => sinTable[((rad * TABLE_SIZE / (Math.PI * 2)) & TABLE_MASK) | 0];
        const fastCos = (rad) => cosTable[((rad * TABLE_SIZE / (Math.PI * 2)) & TABLE_MASK) | 0];
        
        function animate() {
            requestAnimationFrame(animate);
            
            // è®¡ç®—å¹¶æ˜¾ç¤ºå¸§ç‡å’Œå†…å­˜
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
                document.getElementById('fps-display').textContent = fps + ' FPS';
                document.getElementById('fps-display').style.color = fps >= 50 ? '#8f8' : fps >= 30 ? '#fa8' : '#f88';
                
                // æ˜¾ç¤ºå†…å­˜ä½¿ç”¨ï¼ˆå¦‚æœæµè§ˆå™¨æ”¯æŒï¼‰
                if (performance.memory) {
                    const memMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('mem-display').textContent = memMB + 'MB';
                    document.getElementById('mem-display').style.color = memMB < 100 ? '#aaa' : memMB < 200 ? '#fa8' : '#f88';
                }
                
                frameCount = 0;
                lastFpsTime = now;
            }
            
            if (!particles) {
                renderer.render(scene, camera);
                return;
            }
            
            const positions = particles.geometry.attributes.position.array;
            const count = positions.length / 3;
            
            if (!isCollapsed) {
                rotationAngle += 0.01 * config.rotationSpeed;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const seed = i * 0.618;
                    const r = Math.pow((seed * 7.13) % 1, 1/3) * 3;
                    
                    const phi = Math.acos(1 - 2 * (i + 0.5) / count);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i + rotationAngle;
                    
                    const sinPhi = fastSin(phi);
                    const cosPhi = fastCos(phi);
                    const sinTheta = fastSin(theta);
                    const cosTheta = fastCos(theta);
                    
                    const baseX = r * sinPhi * cosTheta;
                    const baseY = r * sinPhi * sinTheta;
                    const baseZ = r * cosPhi;
                    
                    const phase = i * 0.37;
                    const jitterX = fastSin(time * 2.1 + phase) * 0.15;
                    const jitterY = fastCos(time * 1.7 + phase * 1.3) * 0.15;
                    const jitterZ = fastSin(time * 2.5 + phase * 0.8) * 0.15;
                    
                    targetPositions[i3] = baseX + jitterX;
                    targetPositions[i3 + 1] = baseY + jitterY;
                    targetPositions[i3 + 2] = baseZ + jitterZ;
                }
            } else {
                const time = Date.now() * 0.001;
                const breathe = 1 + fastSin(time * 0.5) * 0.03;
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const phase = i * 0.1;
                    const floatX = fastSin(time * 1.5 + phase) * 0.02;
                    const floatY = fastCos(time * 1.2 + phase * 0.7) * 0.02;
                    const floatZ = fastSin(time * 0.8 + phase * 1.3) * 0.03;
                    
                    targetPositions[i3] = originalPositions[i3] * breathe + floatX;
                    targetPositions[i3 + 1] = originalPositions[i3 + 1] * breathe + floatY;
                    targetPositions[i3 + 2] = originalPositions[i3 + 2] + floatZ;
                }
            }
            
            const lerpFactor = 0.05;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] += (targetPositions[i3] - positions[i3]) * lerpFactor;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * lerpFactor;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * lerpFactor;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        async function createHandLandmarker() {
            debugLog('HAND', 'å¼€å§‹åˆ›å»º HandLandmarker...');
            
            // æ£€æŸ¥æ¨¡å—æ˜¯å¦å·²åŠ è½½
            if (!FilesetResolver || !HandLandmarker) {
                debugLog('HAND', 'MediaPipe æ¨¡å—æœªåŠ è½½', { 
                    FilesetResolver: !!FilesetResolver, 
                    HandLandmarker: !!HandLandmarker 
                });
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ¨¡å—æœªåŠ è½½';
                return false;
            }

            try {
                // Step 1: åŠ è½½ FilesetResolver
                debugLog('HAND', 'Step 1: å¼€å§‹åŠ è½½ FilesetResolver (WASM)...');
                const wasmUrl = "https://unpkg.com/@mediapipe/tasks-vision@0.10.0/wasm";
                debugLog('HAND', 'WASM URL', wasmUrl);
                
                const filesetResolver = await FilesetResolver.forVisionTasks(wasmUrl);
                debugLog('HAND', 'Step 1 å®Œæˆ: FilesetResolver åŠ è½½æˆåŠŸ', { 
                    type: typeof filesetResolver 
                });

                // Step 2: åˆ›å»º HandLandmarker
                debugLog('HAND', 'Step 2: å¼€å§‹åˆ›å»º HandLandmarker...');
                // ä½¿ç”¨æœ¬åœ°æ¨¡å‹æ–‡ä»¶
                const modelUrl = "./hand_landmarker.task";
                debugLog('HAND', 'æ¨¡å‹ URL', modelUrl);
                
                // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡ï¼Œç§»åŠ¨è®¾å¤‡ä½¿ç”¨ CPU é¿å…å…¼å®¹æ€§é—®é¢˜
                const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
                const options = {
                    baseOptions: {
                        modelAssetPath: modelUrl,
                        delegate: isMobile ? "CPU" : "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1,
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                };
                debugLog('HAND', 'è®¾å¤‡ç±»å‹', { isMobile, delegate: options.baseOptions.delegate });
                debugLog('HAND', 'åˆ›å»ºé€‰é¡¹', options);

                handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, options);
                debugLog('HAND', 'Step 2 å®Œæˆ: HandLandmarker åˆ›å»ºæˆåŠŸ', { 
                    type: typeof handLandmarker 
                });
                
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ¨¡å‹å·²åŠ è½½';
                return true;
            } catch (error) {
                debugLog('HAND', 'HandLandmarker åˆ›å»ºå¤±è´¥', { 
                    name: error.name,
                    message: error.message, 
                    stack: error.stack 
                });
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šåŠ è½½å¤±è´¥ - ' + error.message;
                return false;
            }
        }

        function startWebcam() {
            debugLog('WEBCAM', 'å¼€å§‹å¯åŠ¨æ‘„åƒå¤´...');
            const video = document.getElementById('webcam-video');
            
            // æ£€æŸ¥ mediaDevices API æ˜¯å¦å¯ç”¨
            if (!navigator.mediaDevices) {
                debugLog('WEBCAM', 'navigator.mediaDevices ä¸å¯ç”¨');
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šä¸æ”¯æŒæ‘„åƒå¤´API';
                document.getElementById('gesture-status').style.color = '#f88';
                return;
            }
            
            if (!navigator.mediaDevices.getUserMedia) {
                debugLog('WEBCAM', 'getUserMedia ä¸å¯ç”¨');
                document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šä¸æ”¯æŒgetUserMedia';
                document.getElementById('gesture-status').style.color = '#f88';
                return;
            }

            debugLog('WEBCAM', 'è¯·æ±‚æ‘„åƒå¤´æƒé™...');
            
            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šä½¿ç”¨å‰ç½®æ‘„åƒå¤´ï¼Œé™ä½åˆ†è¾¨ç‡æå‡æ€§èƒ½
            const constraints = { 
                video: { 
                    facingMode: 'user',  // å‰ç½®æ‘„åƒå¤´
                    width: { ideal: 320 },
                    height: { ideal: 240 }
                } 
            };
            debugLog('WEBCAM', 'æ‘„åƒå¤´çº¦æŸ', constraints);

            navigator.mediaDevices.getUserMedia(constraints)
                .then((stream) => {
                    debugLog('WEBCAM', 'æ‘„åƒå¤´æƒé™è·å–æˆåŠŸ', {
                        tracks: stream.getTracks().map(t => ({ kind: t.kind, label: t.label, readyState: t.readyState }))
                    });
                    video.srcObject = stream;
                    video.style.display = 'block';
                    
                    video.addEventListener('loadeddata', () => {
                        debugLog('WEBCAM', 'è§†é¢‘æ•°æ®å·²åŠ è½½', {
                            videoWidth: video.videoWidth,
                            videoHeight: video.videoHeight,
                            readyState: video.readyState
                        });
                        predictWebcam();
                    });
                    
                    video.addEventListener('error', (e) => {
                        debugLog('WEBCAM', 'è§†é¢‘å…ƒç´ é”™è¯¯', { error: e.message });
                    });
                    
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šå·²å¯ç”¨';
                    document.getElementById('gesture-status').style.color = '#8f8';
                })
                .catch((err) => {
                    debugLog('WEBCAM', 'æ‘„åƒå¤´è®¿é—®å¤±è´¥', { 
                        name: err.name, 
                        message: err.message,
                        constraint: err.constraint 
                    });
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ‘„åƒå¤´é”™è¯¯ - ' + err.message;
                    document.getElementById('gesture-status').style.color = '#f88';
                    gestureEnabled = false;
                    document.getElementById('gesture-btn').textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                    document.getElementById('gesture-btn').classList.remove('active');
                });
        }

        function stopWebcam() {
            const video = document.getElementById('webcam-video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            video.style.display = 'none';
            document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæœªå¯ç”¨';
            document.getElementById('gesture-status').style.color = '#fa8';
        }

        let predictCallCount = 0;
        let lastPredictLog = 0;
        let lastDetectTime = 0;
        let detectInterval = config.detectInterval || 50; // å¯é…ç½®çš„æ£€æµ‹é—´éš”
        let gesturePauseUntil = 0; // æ‰‹åŠ¿åˆ‡æ¢åæš‚åœæ£€æµ‹çš„æ—¶é—´ç‚¹
        let noHandCount = 0; // è¿ç»­æœªæ£€æµ‹åˆ°æ‰‹çš„æ¬¡æ•°
        const IDLE_DETECT_INTERVAL = 300; // ç©ºé—²æ—¶çš„æ£€æµ‹é—´éš”ï¼ˆmsï¼‰
        
        function predictWebcam() {
            const video = document.getElementById('webcam-video');
            predictCallCount++;
            
            // æ¯5ç§’è¾“å‡ºä¸€æ¬¡çŠ¶æ€æ—¥å¿—
            const now = Date.now();
            if (now - lastPredictLog > 5000) {
                debugLog('PREDICT', 'æ£€æµ‹å¾ªç¯çŠ¶æ€', {
                    callCount: predictCallCount,
                    hasHandLandmarker: !!handLandmarker,
                    hasVideoSrc: !!video.srcObject,
                    gestureEnabled: gestureEnabled,
                    videoTime: video.currentTime,
                    videoReady: video.readyState
                });
                lastPredictLog = now;
            }
            
            if (!handLandmarker || !video.srcObject || !gestureEnabled) {
                if (gestureEnabled) requestAnimationFrame(predictWebcam);
                return;
            }

            const nowInMs = performance.now();
            
            // æ‰‹åŠ¿åˆ‡æ¢åæš‚åœæ£€æµ‹ 500ms
            if (nowInMs < gesturePauseUntil) {
                if (gestureEnabled) requestAnimationFrame(predictWebcam);
                return;
            }
            
            // é™åˆ¶æ£€æµ‹é¢‘ç‡ï¼Œé™ä½ CPU è´Ÿè½½
            // æ ¹æ®æ˜¯å¦æ£€æµ‹åˆ°æ‰‹åŠ¨æ€è°ƒæ•´æ£€æµ‹é¢‘ç‡
            const currentInterval = noHandCount > 5 ? IDLE_DETECT_INTERVAL : detectInterval;
            if (nowInMs - lastDetectTime < currentInterval) {
                if (gestureEnabled) requestAnimationFrame(predictWebcam);
                return;
            }
            lastDetectTime = nowInMs;
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                
                // ç”¨ setTimeout æŠŠæ£€æµ‹æ¨è¿Ÿåˆ°ä¸‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œé¿å…é˜»å¡å½“å‰å¸§æ¸²æŸ“
                setTimeout(() => {
                try {
                    const results = handLandmarker.detectForVideo(video, performance.now());
                    
                    if (results.landmarks && results.landmarks.length > 0) {
                        // æ£€æµ‹åˆ°æ‰‹ï¼Œé‡ç½®è®¡æ•°ï¼Œæ¢å¤æ­£å¸¸æ£€æµ‹é¢‘ç‡
                        noHandCount = 0;
                        const newGesture = determineGesture(results.landmarks[0]);
                        
                        if (newGesture && newGesture !== currentGesture) {
                            currentGesture = newGesture;
                            debugLog('GESTURE', 'æ‰‹åŠ¿å˜åŒ–', { gesture: currentGesture });
                            
                            let stateChanged = false;
                            if (currentGesture === 'Fist' && !isCollapsed) {
                                // æ¡æ‹³ â†’ èšåˆæˆå›¾æ¡ˆ
                                setCollapsed(true);
                                stateChanged = true;
                            } else if (currentGesture === 'Open' && isCollapsed) {
                                // å¼ å¼€ â†’ æ‰©æ•£æ—‹è½¬
                                setCollapsed(false);
                                stateChanged = true;
                            }
                            
                            // çŠ¶æ€åˆ‡æ¢åæš‚åœæ£€æµ‹ 500msï¼Œé¿å…è¿ç»­è§¦å‘
                            if (stateChanged) {
                                gesturePauseUntil = performance.now() + 500;
                            }
                            
                            document.getElementById('gesture-status').textContent = 
                                `æ‰‹åŠ¿ï¼š${currentGesture === 'Fist' ? 'âœŠ æ¡æ‹³' : currentGesture === 'Open' ? 'ğŸ–ï¸ å¼ å¼€' : 'è¯†åˆ«ä¸­...'}`;
                        }
                    } else {
                        // æœªæ£€æµ‹åˆ°æ‰‹ï¼Œå¢åŠ è®¡æ•°ï¼Œé€æ¸é™ä½æ£€æµ‹é¢‘ç‡
                        noHandCount++;
                    }
                } catch (detectError) {
                    debugLog('PREDICT', 'æ£€æµ‹å‡ºé”™', { 
                        name: detectError.name,
                        message: detectError.message 
                    });
                }
                }, 0); // setTimeout ç»“æŸ
            }

            if (gestureEnabled) requestAnimationFrame(predictWebcam);
        }

        // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ï¼šæŒ‡å°–yåæ ‡ < æŒ‡æ ¹å…³èŠ‚yåæ ‡
        function fingerExtended(landmarks, tip, pip) {
            return landmarks[tip].y < landmarks[pip].y;
        }

        // æ‹‡æŒ‡ç‰¹æ®Šå¤„ç†ï¼šç”¨xæ–¹å‘åˆ¤æ–­ï¼ˆè€ƒè™‘å·¦å³æ‰‹ï¼‰
        function thumbExtended(landmarks) {
            const wrist = landmarks[0];
            const indexMcp = landmarks[5];
            const isRightHand = wrist.x < indexMcp.x;
            const tip = landmarks[4];
            const ip = landmarks[3];
            return isRightHand ? (tip.x < ip.x) : (tip.x > ip.x);
        }

        function determineGesture(landmarks) {
            // ç»Ÿè®¡ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡
            const ext = [
                thumbExtended(landmarks),           // æ‹‡æŒ‡
                fingerExtended(landmarks, 8, 6),    // é£ŸæŒ‡ï¼šæŒ‡å°–vsæŒ‡æ ¹
                fingerExtended(landmarks, 12, 10),  // ä¸­æŒ‡
                fingerExtended(landmarks, 16, 14),  // æ— åæŒ‡
                fingerExtended(landmarks, 20, 18),  // å°æŒ‡
            ];
            const count = ext.filter(Boolean).length;

            // 0-1æ ¹æ‰‹æŒ‡ä¼¸å‡º = æ¡æ‹³
            if (count <= 1) {
                return 'Fist';
            }
            
            // 4-5æ ¹æ‰‹æŒ‡ä¼¸å‡º = å¼ å¼€
            if (count >= 4) {
                return 'Open';
            }

            return null;
        }

        function setCollapsed(collapsed) {
            isCollapsed = collapsed;
            const toggleBtn = document.getElementById('toggle-btn');
            const status = document.getElementById('status');
            
            if (isCollapsed) {
                toggleBtn.textContent = 'æ‰©æ•£æ—‹è½¬';
                toggleBtn.classList.add('active');
                status.textContent = 'å½“å‰çŠ¶æ€ï¼šèšåˆæˆå›¾æ¡ˆ';
                status.style.color = '#f88';
            } else {
                toggleBtn.textContent = 'èšåˆæˆå›¾æ¡ˆ';
                toggleBtn.classList.remove('active');
                status.textContent = 'å½“å‰çŠ¶æ€ï¼šæ‰©æ•£æ—‹è½¬';
                status.style.color = '#8f8';
            }
        }

        function initUI() {
            const toggleBtn = document.getElementById('toggle-btn');
            const gestureBtn = document.getElementById('gesture-btn');
            
            // åº”ç”¨ä¿å­˜çš„é…ç½®åˆ° UI
            document.getElementById('particle-count').value = config.particleCount;
            document.getElementById('particle-count-val').textContent = config.particleCount;
            document.getElementById('pattern-scale').value = config.patternScale * 100;
            document.getElementById('pattern-scale-val').textContent = (config.patternScale * 100) + '%';
            document.getElementById('rotation-speed').value = config.rotationSpeed * 10;
            document.getElementById('rotation-speed-val').textContent = config.rotationSpeed.toFixed(1);
            document.getElementById('particle-color').value = config.particleColorHex;
            
            toggleBtn.addEventListener('click', () => {
                setCollapsed(!isCollapsed);
            });
            
            gestureBtn.addEventListener('click', async () => {
                debugLog('UI', 'æ‰‹åŠ¿æŒ‰é’®ç‚¹å‡»', { currentEnabled: gestureEnabled });
                
                if (!gestureEnabled) {
                    gestureBtn.textContent = 'åŠ è½½ä¸­...';
                    document.getElementById('gesture-status').textContent = 'æ‰‹åŠ¿ï¼šæ­£åœ¨åŠ è½½æ¨¡å‹...';
                    
                    if (!handLandmarker) {
                        debugLog('UI', 'å¼€å§‹åŠ è½½ HandLandmarker...');
                        const success = await createHandLandmarker();
                        debugLog('UI', 'HandLandmarker åŠ è½½ç»“æœ', { success });
                        if (!success) {
                            gestureBtn.textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                            return;
                        }
                    }
                    gestureEnabled = true;
                    gestureBtn.textContent = 'å…³é—­æ‰‹åŠ¿æ§åˆ¶';
                    gestureBtn.classList.add('active');
                    debugLog('UI', 'å¼€å§‹å¯åŠ¨æ‘„åƒå¤´');
                    startWebcam();
                } else {
                    debugLog('UI', 'å…³é—­æ‰‹åŠ¿æ§åˆ¶');
                    gestureEnabled = false;
                    gestureBtn.textContent = 'å¯ç”¨æ‰‹åŠ¿æ§åˆ¶';
                    gestureBtn.classList.remove('active');
                    stopWebcam();
                }
            });
            
            document.getElementById('particle-count').addEventListener('change', (e) => {
                config.particleCount = parseInt(e.target.value);
                document.getElementById('particle-count-val').textContent = config.particleCount;
                saveConfig();
                createParticles();
            });
            
            document.getElementById('pattern-scale').addEventListener('input', (e) => {
                config.patternScale = e.target.value / 100;
                document.getElementById('pattern-scale-val').textContent = e.target.value + '%';
                saveConfig();
                updatePatternScale();
            });
            
            document.getElementById('rotation-speed').addEventListener('input', (e) => {
                config.rotationSpeed = e.target.value / 10;
                document.getElementById('rotation-speed-val').textContent = config.rotationSpeed.toFixed(1);
                saveConfig();
            });
            
            document.getElementById('particle-color').addEventListener('input', (e) => {
                config.particleColor = new THREE.Color(e.target.value);
                config.particleColorHex = e.target.value;
                if (particles) particles.material.color = config.particleColor;
                saveConfig();
            });
            
            // æ¸²æŸ“è´¨é‡æ§åˆ¶
            document.getElementById('pixel-ratio').value = config.pixelRatio * 10;
            document.getElementById('pixel-ratio-val').textContent = config.pixelRatio.toFixed(1);
            document.getElementById('pixel-ratio').addEventListener('input', (e) => {
                config.pixelRatio = e.target.value / 10;
                document.getElementById('pixel-ratio-val').textContent = config.pixelRatio.toFixed(1);
                renderer.setPixelRatio(config.pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                saveConfig();
            });
            
            // æ‰‹åŠ¿æ£€æµ‹é¢‘ç‡æ§åˆ¶
            document.getElementById('detect-interval').value = config.detectInterval;
            document.getElementById('detect-interval-val').textContent = config.detectInterval + 'ms';
            document.getElementById('detect-interval').addEventListener('input', (e) => {
                config.detectInterval = parseInt(e.target.value);
                detectInterval = config.detectInterval;
                document.getElementById('detect-interval-val').textContent = config.detectInterval + 'ms';
                saveConfig();
            });
            
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                    hideUI();
                } else {
                    document.exitFullscreen();
                }
            });
            
            // ESC é”®åˆ‡æ¢ UI æ˜¾ç¤º
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    toggleUI();
                }
            });
            
            // åŒå‡»å±å¹•é€€å‡ºå…¨å±å¹¶æ˜¾ç¤º UI
            let lastTap = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTap < 300) {
                    // åŒå‡»æ£€æµ‹
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                    showUI();
                }
                lastTap = now;
            });
            
            // é¼ æ ‡åŒå‡»ä¹Ÿæ”¯æŒ
            document.addEventListener('dblclick', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                showUI();
            });
            
            document.getElementById('image-upload').addEventListener('change', (e) => {
                debugLog('UI', 'å›¾ç‰‡é€‰æ‹©äº‹ä»¶è§¦å‘');
                const file = e.target.files[0];
                if (file) {
                    debugLog('UI', 'é€‰æ‹©äº†æ–‡ä»¶', { name: file.name, size: file.size, type: file.type });
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        debugLog('UI', 'æ–‡ä»¶è¯»å–å®Œæˆ');
                        currentImageData = event.target.result;
                        createParticles();
                    };
                    reader.onerror = (err) => {
                        debugLog('UI', 'æ–‡ä»¶è¯»å–å¤±è´¥', { error: err });
                    };
                    reader.readAsDataURL(file);
                } else {
                    debugLog('UI', 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
                }
            });
        }
        
        function updatePatternScale() {
            if (!originalPositions || !currentImageData) return;
            const count = originalPositions.length / 3;
            const scale = config.patternScale * 4;
            
            loadImage(currentImageData).then(img => {
                const sampledPoints = sampleFromImage(img, count);
                for (let i = 0; i < Math.min(count, sampledPoints.length); i++) {
                    const i3 = i * 3;
                    originalPositions[i3] = sampledPoints[i].x * scale;
                    originalPositions[i3 + 1] = sampledPoints[i].y * scale;
                }
            });
        }

        let uiHidden = false;
        
        function hideUI() {
            uiHidden = true;
            document.getElementById('control-panel').style.display = 'none';
            document.getElementById('webcam-video').style.visibility = 'hidden';
        }
        
        function showUI() {
            uiHidden = false;
            document.getElementById('control-panel').style.display = 'block';
            if (gestureEnabled) {
                document.getElementById('webcam-video').style.visibility = 'visible';
            }
        }
        
        function toggleUI() {
            if (uiHidden) {
                showUI();
            } else {
                hideUI();
            }
        }

        try {
            debugLog('INIT', 'å¼€å§‹åˆå§‹åŒ– Three.js');
            initThree();
            debugLog('INIT', 'Three.js åˆå§‹åŒ–å®Œæˆ');
            
            debugLog('INIT', 'å¼€å§‹åˆå§‹åŒ– UI');
            initUI();
            debugLog('INIT', 'UI åˆå§‹åŒ–å®Œæˆ');
            
            debugLog('INIT', 'å¼€å§‹åŠ¨ç”»å¾ªç¯');
            animate();
            debugLog('INIT', 'å…¨éƒ¨åˆå§‹åŒ–å®Œæˆ');
            
            // é»˜è®¤å¯ç”¨æ‰‹åŠ¿æ§åˆ¶
            debugLog('INIT', 'è‡ªåŠ¨å¯ç”¨æ‰‹åŠ¿æ§åˆ¶...');
            setTimeout(() => {
                document.getElementById('gesture-btn').click();
            }, 500);
        } catch (initError) {
            debugLog('INIT', 'åˆå§‹åŒ–å¤±è´¥', { 
                name: initError.name, 
                message: initError.message,
                stack: initError.stack 
            });
        }
    </script>
</body>
</html>
